.ORIG x3000

;the snippet that clears memory

JSR CLEAR_ADDRESS

;Current slot in R5
;String address in R4
;bit pattern for days in R0 (along with other stuff)
;Current address in R1
;all sorts of counting can be done using R3 (shift left, looking for null terminator)

LD R1, TABLE_ADDRESS

FIXED_LEN
LDR R0, R1, #0
BRz MADE_FIXED_LEN
AND R4, R4, #0
ADD R4, R4, R1

STRING_NULL
ADD R1, R1, #1
LDR R0, R1, #0
BRnp STRING_NULL

ADD R1, R1, #2
LDR R0, R1, #0
ADD R0, R0, #-15
BRp ERROR_2

ADD R0, R0, #15
LEA R5, SLOT_ADDRESS
ADD R5, R5, R0
LDR R5, R5, #0

ADD R1, R1, #-1
LDR R0, R1, #0

AND R3, R3, #0
ADD R3, R3, #11
SHIFT_ELEVEN
ADD R0, R0, R0
ADD R3, R3, #-1
BRp SHIFT_ELEVEN

ADD R0, R0, #0
BRn ADD_F

F_DONE
ADD R0, R0, R0
BRn ADD_R

R_DONE
ADD R0, R0, R0
BRn ADD_W

W_DONE
ADD R0, R0, R0
BRn ADD_T

T_DONE
ADD R0, R0, R0
BRn ADD_M

M_DONE
ADD R1, R1, #2
BRnzp FIXED_LEN

MADE_FIXED_LEN
LD R0, SPACE
AND R3, R3, #0
ADD R3, R3, #6

SIX_SPACES
OUT
ADD R3, R3, #-1
BRp SIX_SPACES

LD R0, VLINE
OUT

LEA R1, MON
JSR PRINT_CENTERED
LD R0, VLINE
OUT

LEA R1, TUE
JSR PRINT_CENTERED
LD R0, VLINE
OUT

LEA R1, WED
JSR PRINT_CENTERED
LD R0, VLINE
OUT

LEA R1, THU
JSR PRINT_CENTERED
LD R0, VLINE
OUT

LEA R1, FRI
JSR PRINT_CENTERED

AND R4, R4, #0
LD R3, SLOT_ADDRESS

PRINT_SCHEDULE
LD R0, NEWLINE
OUT
AND R1, R1, #0
ADD R1, R1, R4
JSR PRINT_SLOT
LD R0, VLINE
OUT

PRINT_ALL_DAYS
LDR R1, R3, #0
BRnp PRINT_ITEM
BRz SIX_SPACES_2 

ITEM_PRINTED

ADD R3, R3, #1
LEA R5, SLOT_ADDRESS
ADD R5, R5, R4
ADD R5, R5, #1
LDR R5, R5, #0
NOT R5, R5
ADD R5, R5, #1
ADD R6, R5, R3
BRz NEXT_SLOT
LD R0, VLINE
OUT
BRnzp PRINT_ALL_DAYS

NEXT_SLOT
ADD R4, R4, #-15
BRz DONE_PRINTING
ADD R4, R4, #15
ADD R4, R4, #1
BRnzp PRINT_SCHEDULE

DONE_PRINTING
LD R0, VLINE
OUT
HALT

PRINT_ITEM
JSR PRINT_CENTERED
BRnzp ITEM_PRINTED

SIX_SPACES_2
LD R0, SPACE
OUT
OUT
OUT
OUT
OUT
OUT
BRnzp ITEM_PRINTED

CLEAR_ADDRESS
AND R1, R1, #0
LD R2, LAST_ADDRESS
LD R3, MINUS_FIRST_ADDRESS

CLEAR
STR R1, R2, #0
ADD R2, R2, #-1
ADD R4, R2, R3
BRzp CLEAR

RET

ADD_M
LDR R3, R5, #0
BRnp ERROR_1
STR R4, R5, #0
BRnzp M_DONE

ADD_T
ADD R5, R5, #1
LDR R3, R5, #0
BRnp ERROR_1
STR R4, R5, #0
ADD R5, R5, #-1
BRnzp T_DONE

ADD_W
ADD R5, R5, #2
LDR R3, R5, #0
BRnp ERROR_1
STR R4, R5, #0
ADD R5, R5, #-2
BRnzp W_DONE

ADD_R
ADD R5, R5, #3
LDR R3, R5, #0
BRnp ERROR_1
STR R4, R5, #0
ADD R5, R5, #-3
BRnzp R_DONE

ADD_F
ADD R5, R5, #4
LDR R3, R5, #0
BRnp ERROR_1
STR R4, R5, #0
ADD R5, R5, #-4
BRnzp F_DONE

ERROR_1
AND R0, R0, #0
ADD R0, R0, R4
PUTS
LEA R0, ERROR_MESSAGE_1
PUTS
LD R0, NEWLINE
OUT
HALT

ERROR_2
AND R0, R0, #0
ADD R0, R0, R4
PUTS
LEA R0, ERROR_MESSAGE_2
PUTS
LD R0, NEWLINE
OUT
HALT

VLINE
.FILL x007C

BACKSPACE
.FILL x0008

SLOT_ADDRESS
.FILL x4000
.FILL x4005
.FILL x400A
.FILL x400F
.FILL x4014
.FILL x4019
.FILL x401E
.FILL x4023
.FILL x4028
.FILL x402D
.FILL x4032
.FILL x4037
.FILL x403C
.FILL x4041
.FILL x4046
.FILL x404B
.FILL x404F

TABLE_ADDRESS
.FILL x5000

ERROR_MESSAGE_1
.STRINGZ " conflicts with an earlier event."

ERROR_MESSAGE_2
.STRINGZ " has an invalid slot number."

MON
.STRINGZ "Mon"

TUE
.STRINGZ "Tue"

WED
.STRINGZ "Wed"

THU
.STRINGZ "Thu"

FRI
.STRINGZ "Fri"

NEWLINE
.FILL x000A

MINUS_FIRST_ADDRESS
.FILL xC000

LAST_ADDRESS
.FILL x404F

ZERO
.FILL X0030           ;ascii for zero

SEVEN
.Fill x0037           ;ascii for seven

COLON
.FILL X003A           ;ascii for colon

RETURN_ADDRESS
.FILL x0000           ;storage space for return address of main subroutines

RETURN_ADDRESS_1
.FILL x0000           ;storage space for subroutines called inside subroutines

R_ZERO
.FILL x0000           ;these are storage space for R0-R6 as R-<register number>

R_ONE
.FILL x0000

R_TWO
.FILL x0000

R_THREE
.FILL x0000

R_FOUR
.FILL x0000

R_FIVE
.FILL x0000

R_SIX
.FILL x0000

SPACE
.FILL x0020         ;ascii for space

;this is the lookup table used for determining number
;of leading spaces needed for a string of length between
;0 and 6

LEADING_SPACES
.FILL x0006
.FILL x0002
.FILL x0002
.FILL x0001
.FILL x0001
.FILL x0000
.FILL x0000

;This subroutine takes in a number between 0-15 in R1
;and prints out the corresponding time slot.
;it works by dividing the given number into 3 possible
;sets of numbers, and depending on which set the given
;number lies in, it prints out a corresponding first digit
;and then the corresponding second digit, followed by a
;common set of characters.
;All register values are saved by the subroutine
;Call by storing a value in R1, then JSR PRINT_SLOT

PRINT_SLOT

ST R7, RETURN_ADDRESS    ;Store the address to return to
JSR STORE_REGISTERS      ;Go to subroutine to store register values
ADD R1, R1, #-2          ;check if the first digit to be printed is zero
BRnz OUT_ZERO            ;if it is, go to OUT_ZERO (to output a zero)
ADD R1, R1, #-10         ;if it isn't, check if first digit is a one
BRnz OUT_ONE             ;if it is, go to OUT_ONE (to output a one)
BRnzp OUT_TWO            ;go to OUT_TWO to out a two

OUT_ZERO
LD R0, ZERO              ;load ascii value of zero into R0
OUT                      ;TRAP for displaying R0
ADD R1, R1, #2           ;subtracted 2 before branch, add it back
BRnzp USE_SEVEN          ;Go to USE_SEVEN- adds R1 to seven, prints it

OUT_ONE
LD R0, ZERO              ;load ascii value of zero into R0
ADD R0, R0, #1           ;ADD #1 to it, because we want to output one
OUT                      ;TRAP for displaying R0
ADD R1, R1, #9           ;Given number was between 3-12, make it between 0-9
BRnzp USE_ZERO           ;go to USE_ZERO- outputs corresponding second digit

OUT_TWO
LD R0, ZERO              ;load ascii value of zero into R0
ADD R0, R0, #2           ;add #2, because we want to output two
OUT                      ;TRAP for displaying R0
ADD R1, R1, #-1          ;Given number was between 13-15, make it between 0-2
BRnzp USE_ZERO           ;go to USE_ZERO - outputs corresponding second digit

USE_ZERO
LD R6, ZERO              ;load ascii value of zero into R6
ADD R0, R1, R6           ;add R1 and R6 and store into R0
OUT                      ;TRAP for displaying R0
BRnzp PRINT_REST         ;Go to PRINT_REST - to print ":00"

USE_SEVEN
LD R6, SEVEN             ;load ascii value of seven into R6
ADD R0, R1, R6           ;add R1 ad R6 and store into R0
OUT                      ;TRAP for displaying ascii in R0
BRnzp PRINT_REST         ;Go to PRINT_REST - to print ":00"

PRINT_REST
LD R0, COLON             ;Load ascii for colon into R0
OUT                      ;output a colon
LD R0, ZERO              ;ascii for zero into R0
OUT                      ;output 0 to display
OUT                      ;output 0 to display
LD R0, SPACE             ;load ascii for space
OUT                      ;output a space

JSR LOAD_REGISTERS       ;go to subroutine to load back register values
LD R7, RETURN_ADDRESS    ;load address from where subroutine was called
RET                      ;return to that address

;This subroutine takes a string a outputs such that
;it appears to be centered by padding it with an apt
;number of spaces, or by truncating it. This is done
;by first calculating the string length, determining the
;amount of leading spaces needed using a lookup table
;(called LEADING_SPACES), then calculating the trailing
;spaces by subtracting the sum of the string length and
;leading spaces from 6. All registers are stored by this
;subroutine. Store the address of the starting of the
;string in R1 then JSR PRINT_CENTERED to use the subroutine.

PRINT_CENTERED
ST R7, RETURN_ADDRESS    ;Store the address to return to
JSR STORE_REGISTERS      ;go to subroutine to store register values
AND R2, R2, #0           ;Clear R2
AND R3, R3, #0           ;Clear R3
AND R4, R4, #0           ;Clear R4
AND R5, R5, #0           ;Clear R5
ADD R2, R1, #0           ;Duplicate R1 into R2

STRING_LENGTH
LDR R6, R2, #0           ;Get ascii stored at address in R2
BRz PRINT_LEADING        ;If it's null, go to PRINT_LEADING
ADD R4, R4, #1           ;Else, increment string length (in R4)
ADD R2, R2, #1           ;Increment address in R2
BRnzp STRING_LENGTH      ;go back to the loop

PRINT_LEADING
ADD R4, R4, #-6          ;Check if length is more than 6
BRp MORE_THAN_SIX        ;if yes, go to MORE_THAN_SIX (truncates string)
ADD R4, R4, #6           ;if not, restore string length
LEA R2, LEADING_SPACES   ;Store initial address of lookup table in R2
ADD R2, R2, R4           ;Get the address needed for given length
LDR R3, R2, #0           ;Load the number of leading spaces into R3
ADD R5, R3, #0           ;Store it into R5
JSR PRINT_SPACES         ;Go to subroutine for printing spaces

PRINT_STRING
ADD R0, R1, #0           ;Put the starting string address into R0
PUTS                     ;output the string

PRINT_TRAILING
ADD R5, R4, R3           ;Add string length, leading spaces, into R5
ADD R5, R5, #-6          ;R5-6
NOT R5, R5               ;Negate R5
ADD R5, R5, #1           ;add one to convert R5 into -R5
JSR PRINT_SPACES         ;go to subroutine for printing spaces
BRnzp DONE               ;go to halt section

MORE_THAN_SIX
ADD R3, R3, #6           ;initialize counter to 6

PRINT
LDR R0, R1, #0           ;Load ascii in address R1 into R1
OUT                      ;display said ascii character
ADD R1, R1, #1           ;increment address
ADD R3, R3, #-1          ;decrement counter
BRz DONE                 ;if counter is zero, we're done
BRnzp PRINT              ;if not, then print again.

DONE
JSR LOAD_REGISTERS       ;load back inital register values
LD R7, RETURN_ADDRESS    ;load back address we're supposed to return to
RET                      ;return to said address

;this subroutine prints a specified number of spaces
;the number of spaces to be printed should be in R5
;the subroutine doesn't save any register values
;to call it, store number of spaces in R5, then
;JSR PRINT_SPACES

PRINT_SPACES
LD R0, SPACE            ;load ascii for space into R0
ST R7, RETURN_ADDRESS_1 ;store return address of caller

SPACE_LOOP
ADD R5, R5, #0          ;set cc for number of spaces to be printed
BRz NO_SPACES           ;if no spaces left, we're done
OUT                     ;else, print a space
ADD R5, R5, #-1         ;decrement number of spaces to be printed
BRp SPACE_LOOP          ;return to loop

NO_SPACES
LD R7, RETURN_ADDRESS_1 ;if no more spaces left, load return address
RET                     ;return to that address


;subroutine for storing registers
;stores registers r0-r6
;store r7 before calling if needed
;call as JSR STORE_REGISTERS

STORE_REGISTERS
ST R1, R_ONE           ;all lines store respective register in
ST R2, R_TWO           ;their respective memory location
ST R3, R_THREE
ST R4, R_FOUR
ST R5, R_FIVE
ST R6, R_SIX
ST R0, R_ZERO
RET                    ;return to caller

;subroutine to load back registers
;stores registers r0-r6
;store r7 before calling if needed
;call as JSR LOAD_REGISTERS

LOAD_REGISTERS
LD R1, R_ONE          ;all lines load respective register from
LD R2, R_TWO          ;their respective memory location
LD R3, R_THREE
LD R4, R_FOUR
LD R5, R_FIVE
LD R6, R_SIX
LD R0, R_ZERO
RET                   ;return to caller

.END

