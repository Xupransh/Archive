/*									tab:8
 *
 * main.c - skeleton source file for ECE220 picture drawing program
 *
 * "Copyright (c) 2018 by Charles H. Zega, and Saransh Sinha."
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice and the following
 * two paragraphs appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE AUTHOR OR THE UNIVERSITY OF ILLINOIS BE LIABLE TO
 * ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
 * DAMAGES ARISING OUT  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
 * EVEN IF THE AUTHOR AND/OR THE UNIVERSITY OF ILLINOIS HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHOR AND THE UNIVERSITY OF ILLINOIS SPECIFICALLY DISCLAIM ANY
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE
 * PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND NEITHER THE AUTHOR NOR
 * THE UNIVERSITY OF ILLINOIS HAS ANY OBLIGATION TO PROVIDE MAINTENANCE,
 * SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS."
 *
 * Author:	    Charles Zega, Saransh Sinha
 * Version:	    1
 * Creation Date:   12 February 2018
 * Filename:	    mp5.h
 * History:
 *	CZ	1	12 February 2018
 *		First written.
 */
#include "mp5.h"
#include <stdlib.h>
#include <stdio.h>

/*
	You must write all your code only in this file, for all the functions!
*/

/*#include <assert.h>
 *  near_horizontal
 *#include <assert.h>
 *
 *
 *
 * INPUTS: x_start,y_start -- the coordinates of the pixel at one end of the line
 * 	   x_end, y_end    -- the coordinates of the pixel at the other end
 * OUTPUTS: draws a pixel to all points in between the two given pixels including
 *          the end points
 * RETURN VALUE: 0 if any of the pixels drawn are out of bounds, otherwise 1
 * SIDE EFFECTS: none
 */


int32_t 
point_color(int32_t x, int32_t y);


int32_t
near_horizontal(int32_t x_start, int32_t y_start, int32_t x_end, int32_t y_end){
	/* Your code goes here! */
    if(x_start > x_end)
    {
        int32_t temp = x_start;
        x_start = x_end;
        x_end = temp;
        temp = y_start;
        y_start = y_end;
        y_end = temp;
    }

    if(x_start == x_end && y_start == y_end)
    {
        int32_t return_val = draw_dot(x_start, y_start);
        return return_val;
    }

    int32_t x_current = x_start;
    int32_t y_current = y_start;
    int32_t return_draw = 0;
    int32_t return_val = 1;
    do
    {
        return_draw = draw_dot(x_current, y_current);
        if(return_draw == 0)
           return_val = 0;

        x_current += 1;
        y_current = ((2*(y_end-y_start)*(x_current - x_start)+1)/(2*(x_end-x_start))) + y_start;
    }
    while(x_current <= x_end);

    return return_val;
}


/*
 *  near_vertical
 *
 *
 *
 *
 * INPUTS: x_start,y_start --#include <assert.h> the coordinates of the pixel at one end of the line
 * 	   x_end, y_end    -- the coordinates of the pixel at the other end
 * OUTPUTS: draws a pixel to all points in between the two given pixels including
 *          the end points
 * RETURN VALUE: 0 if any of the pixels drawn are out of bounds, otherwise 1
 * SIDE EFFECTS: none
 */

int32_t
near_vertical(int32_t x_start, int32_t y_start, int32_t x_end, int32_t y_end){
	/* Your code goes here! */
    if(y_start > y_end)
    {
        int32_t temp = y_start;
        y_start = y_end;
        y_end = temp;
        temp = x_start;
        x_start = x_end;
        x_end = temp;
    }

    if(x_start == x_end && y_start == y_end)
    {
        int32_t return_val = draw_dot(x_start, y_start);
        return return_val;
    }

    int32_t x_current = x_start;
    int32_t y_current = y_start;
    int32_t return_draw = 0;
    int32_t return_val = 1;
    do
    {
        return_draw = draw_dot(x_current, y_current);
        if(return_draw == 0)
           return_val = 0;

        y_current += 1;
        x_current = ((2*(x_end-x_start)*(y_current - y_start)+1)/(2*(y_end-y_start))) + x_start;
    }
    while(y_current <= y_end);

    return return_val;
}

/*
 *  draw_line
 *
 *
 *
 *
 * INPUTS: x_start,y_start -- the coordinates of the pixel at one end of the line
 * 	   x_end, y_end    -- the coordinates of the pixel at the other end
 * OUTPUTS: draws a pixel to all points in between the two given pixels including
 *          the end points
 * RETURN VALUE: 0 if any of the pixels drawn are out of bounds, otherwise 1
 * SIDE EFFECTS: none
 */

int32_t
draw_line(int32_t x_start, int32_t y_start, int32_t x_end, int32_t y_end){
	/* Your code goes here! */
    int32_t slope_num = (y_end>y_start)?(y_end-y_start):(y_start-y_end);
    int32_t slope_denum = (x_end>x_start)?(x_end-x_start):(x_start-x_end); 
    int32_t return_near = (slope_num<=slope_denum)?
    (near_horizontal(x_start, y_start, x_end, y_end)):(near_vertical(x_start, y_start, x_end, y_end));

    if(return_near == 0)
            return 0;

    return 1;
}


/*
 *  draw_rect
 *
 *
 *
 *
 * INPUTS: x,y -- the coordinates of the of the top-left pixel of the rectangle
 *         w,h -- the width and height, respectively, of the rectangle
 * OUTPUTS: draws a pixel to every point of the edges of the rectangle
 * RETURN VALUE: 0 if any of the pixels drawn are out of bounds, otherwise 1
 * SIDE EFFECTS: none
 */

int32_t
draw_rect(int32_t x, int32_t y, int32_t w, int32_t h){
	/* Your code goes here! */
    if(w < 0 || h < 0)
	    return 0;

    int32_t x_current = x;
    int32_t y_current = y;
    int32_t return_draw = 0;
    int32_t return_val = 1;

    while(y_current <= y+h)
    {
        return_draw = (draw_line(x_current, y_current, (x_current+w), y_current));
        if(return_draw == 0)
            return_val = 0;

        y_current += h;
    }

    y_current = y;

    while(x_current <= x+w)
    {
        return_draw =  (draw_line(x_current, y_current, x_current, (y_current+h) ));
        if(return_draw == 0)
            return_val = 0;

        x_current += w;
    }

    return return_val;
}


/*
 *  draw_triangle
 *
 *
 *
 *
 * INPUTS: x_A,y_A -- the coordinates of one of the vertices of the triangle
 *         x_B,y_B -- the coordinates of another of the vertices of the triangle
 *         x_C,y_C -- the coordinates of the final of the vertices of the triangle
 * OUTPUTS: draws a pixel to every point of the edges of the triangle
 * RETURN VALUE: 0 if any of the pixels drawn are out of bounds, otherwise 1
 * SIDE EFFECTS: none
 */

int32_t
draw_triangle(int32_t x_A, int32_t y_A, int32_t x_B, int32_t y_B, int32_t x_C, int32_t y_C){
	/* Your code goes here! */
    int32_t rval_1, rval_2, rval_3 = 1;
    rval_1 = draw_line(x_A, y_A, x_B, y_B);
    rval_2 = draw_line(x_B, y_B, x_C, y_C);
    rval_3 = draw_line(x_A, y_A, x_C, y_C);

	return rval_1 && rval_2 && rval_3;
}

/*
 *  draw_parallelogram
 *
 *
 *
 *
 * INPUTS: x_A,y_A -- the coordinates of one of the vertices of the parallelogram
 *         x_B,y_B -- the coordinates of another of the vertices of the parallelogram
 *         x_C,y_C -- the coordinates of another of the vertices of the parallelogram
 * OUTPUTS: draws a pixel to every point of the edges of the parallelogram
 * RETURN VALUE: 0 if any of the pixels drawn are out of bounds, otherwise 1
 * SIDE EFFECTS: none
 */

int32_t
draw_parallelogram(int32_t x_A, int32_t y_A, int32_t x_B, int32_t y_B, int32_t x_C, int32_t y_C){
	/* Your code goes here! */
    int32_t x_D = (x_A+x_C-x_B);
    int32_t y_D = (y_A+y_C-y_B);
    int32_t rval_1, rval_2, rval_3, rval_4 = 1;

    rval_1 = draw_line(x_A, y_A, x_B, y_B);
    rval_2 = draw_line(x_B, y_B, x_C, y_C);
    rval_3 = draw_line(x_C, y_C, x_D, y_D);
    rval_4 = draw_line(x_A, y_A, x_D, y_D);

	return rval_1 && rval_2 && rval_3 && rval_4;
}


/*
 *  draw_circle
 *
 *
 *
 *
 * INPUTS: x,y -- the center of the circle
 *         inner_r,outer_r -- the inner and outer radius of the circle
 * OUTPUTS: draws a pixel to every point whose distance from the center is
 * 	    greater than or equal to inner_r and less than or equal to outer_r
 * RETURN VALUE: 0 if any of the pixels drawn are out of bounds, otherwise 1
 * SIDE EFFECTS: none
 */

int32_t
draw_circle(int32_t x, int32_t y, int32_t inner_r, int32_t outer_r){
	/* Your code goes here!*/

    if(inner_r < 0 || outer_r < inner_r)
	     return 0;

    int32_t x_square_1 = x-outer_r-1;
    int32_t x_square_2 = x+outer_r+1;
    int32_t y_square_1 = y-outer_r-1;
    int32_t y_square_2 = y+outer_r+1;
    int32_t x_current, y_current, distance = 0;
    int32_t return_val = 1;
    int32_t return_draw = 1;

    if(inner_r == 0 && outer_r == 0)
    {
        return_val = draw_dot(x,y);
        return return_val;
    }

    for(x_current = x_square_1; x_current < x_square_2 ; x_current++)
    {
        for(y_current = y_square_1; y_current < y_square_2 ; y_current++)
        {
            distance = ((x_current-x)*(x_current-x) + (y_current-y)*(y_current-y));
            if( distance >= inner_r*inner_r  && outer_r*outer_r >= distance)
                return_draw = draw_dot(x_current, y_current);

            if(return_draw == 0)
                return_val = 0;
        }
    }
        return return_val;
}


/*
 *  rect_gradient
 *
 *
 *
 *
 * INPUTS: x,y -- the coordinates of the of the top-left pixel of the rectangle
 *         w,h -- the width and height, respectively, of the rectangle
 *         start_color -- the color of the far left side of the rectangle
 *         end_color -- the color of the far right side of the rectangle
 * OUTPUTS: fills every pixel within the bounds of the rectangle with a color
 *	    based on its position within the rectangle and the difference in
 *          color between start_color and end_color
 * RETURN VALUE: 0 if any of the pixels drawn are out of bounds, otherwise 1
 * SIDE EFFECTS: none
 */

int32_t
rect_gradient(int32_t x, int32_t y, int32_t w, int32_t h, int32_t start_color, int32_t end_color){
	/* Your code goes here! */
    if(h < 0 || w < 0)
	    return 0;

    int32_t x_right = x+w;
    int32_t y_bottom = y+h;
    int32_t x_current = x;
    int32_t y_current = y;
    int32_t bitmask_red = 0xff0000;
    int32_t bitmask_green = 0x00ff00;
    int32_t bitmask_blue = 0x0000ff;
    int32_t i, return_draw = 0;
    int32_t return_val = 1;
    int32_t level[3];
    int32_t color = 0;
    int32_t levels_fixed[3][2] = {{(start_color&bitmask_red)>>16,  (end_color&bitmask_red)>>16}, {(start_color&bitmask_green)>>8, (end_color&bitmask_green)>>8},
      {start_color&bitmask_blue,  end_color&bitmask_blue}};

    for(x_current = x; x_current <= x_right ; x_current++)
    {
        for(y_current = y; y_current <= y_bottom; y_current++)
        {
            for(i = 0; i <= 2; i++)
                level[i] = ((((2*(x_current - x)*(levels_fixed[i][1]-levels_fixed[i][0])) + 1))/((2*(-x+x_right)))) + levels_fixed[i][0];

            color = (level[0]<<16) | (level[1]<<8) | (level[2]) ;
            set_color(color);
            return_draw = draw_dot(x_current, y_current);

            if(return_draw == 0)
                return_val = 0;
        }
    }

    return return_val;
}

/*
 *  draw_picture
 *
 *
 *
 *
 * INPUTS: none
 * OUTPUTS: alters the image by calling any of the other functions in the file
 * RETURN VALUE: 0 if any of the pixels drawn are out of bounds, otherwise 1
 * SIDE EFFECTS: none
 */


int32_t
draw_picture()
{
	/* Your code goes here! */
    int32_t max_x = 624;
    int32_t max_y = 320;
    int32_t x, y , color = 0; 
    for(x = 0; x < max_x ; x++)
    {
        for(y = 0; y < max_y ; y++)
        {
            color = point_color(x,y);
            set_color(color);
            draw_dot(x,y);
        }
    }
    return 1;
}

int32_t
point_color(int32_t x, int32_t y)
{
    int32_t r, g, b = 0;

    if(x == 0 || y == 0)
        return 0; 

    r = (2*x+2*y)%225;
    g = (2*x)%255;
    b = (2*y)%255;
    
    int32_t color = (r)<<16 | (g) <<8 | (b); 
    
    return color;
}



