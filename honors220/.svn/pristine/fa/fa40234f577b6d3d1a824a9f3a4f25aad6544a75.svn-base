#include <stdint.h>
#include <stdio.h>

#include "mp10.h"

void
markWithIndex(graph_t *g)
{
    int32_t i;
    for(i = 0; i < g->n_vertices; i++)
      g->vertex[i].mm_bit = i;
}

int32_t
findPyramidAncestor(vertex_t vs, pyr_tree_t *p, int32_t count, int32_t p_index)
{
    if(count == 4)
        return p_index;

    if(vs.x < p->node[p_index].x)
    {
        if(vs.y < p->node[p_index].y_left)
            return findPyramidAncestor(vs,p,++count,4*p_index+1);
        else
            return findPyramidAncestor(vs,p,++count,4*p_index+3);
    }
    else
    {
        if(vs.y < p->node[p_index].y_right)
            return findPyramidAncestor(vs,p,++count,4*p_index+2);
        else
            return findPyramidAncestor(vs,p,++count,4*p_index+4);
    }
}

int32_t
mark_vertex_minimap (graph_t* g, pyr_tree_t* p)
{
    if(g->n_vertices <= 64)
        markWithIndex(g);

    //count the level, index into the vertex array
    int32_t count, v_index = 0, p_index = 0;

    while(v_index < g->n_vertices)
    {
        count = 1;
        g->vertex[v_index].mm_bit = findPyramidAncestor(g->vertex[v_index], p, count, p_index) - 21;
        v_index++;
        p_index = 0;
    }
    return 1;
}


void
build_vertex_set_minimap (graph_t* g, vertex_set_t* vs)
{
    int32_t i;
    int32_t minimap = 0;
    for(i = 0; i < vs->count; i++)
    {
        minimap |= 1ULL<<(g->vertex[vs->id[i]].mm_bit);
    }

    vs->minimap = (unsigned long long)minimap;
}


void
build_path_minimap (graph_t* g, path_t* p)
{
    int32_t i;
    int32_t minimap = 0;
    for(i = 0; i < p->n_vertices; i++)
    {
        minimap |= 1ULL<<(g->vertex[p->id[i]].mm_bit);
    }

    p->minimap = (unsigned long long)minimap;
}


int32_t
merge_vertex_sets (const vertex_set_t* v1, const vertex_set_t* v2,
		   vertex_set_t* vint)
{
    int32_t i = 0;
    int32_t j = 0;
    vint->count = 0;
    do
    {
        if(v1->id[i] == v2->id[j])
        {
            if(vint->count > vint->id_array_size)
            {
                if(!resizeVertexSetID(vint))
                    return -1;
            }
            vint->id[vint->count++] = v1->id[i];
            i++;
        }
        else if(v1->id[i] < v2->id[j])
        {
            i++;
            j=0;
        }
        else
            j++;
        if(j>=v2->count)
        {
           i++;
           j = 0;
        }
    }
    while(i<v1->count);
    return (vint->count > 0);
}
