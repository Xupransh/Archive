//									tab:8
//
// mp12.cpp - source file for Spring 2018 MP12 student code
//
// "Copyright (c) 2018 by Steven S. Lumetta."
//
// Permission to use, copy, modify, and distribute this software and its
// documentation for any purpose, without fee, and without written agreement is
// hereby granted, provided that the above copyright notice and the following
// two paragraphs appear in all copies of this software.
//
// IN NO EVENT SHALL THE AUTHOR OR THE UNIVERSITY OF ILLINOIS BE LIABLE TO
// ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
// DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE AUTHOR AND/OR THE UNIVERSITY OF ILLINOIS HAS BEEN ADVISED
// OF THE POSSIBILITY OF SUCH DAMAGE.
//
// THE AUTHOR AND THE UNIVERSITY OF ILLINOIS SPECIFICALLY DISCLAIM ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND NEITHER THE AUTHOR NOR
// THE UNIVERSITY OF ILLINOIS HAS ANY OBLIGATION TO PROVIDE MAINTENANCE,
// SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS."
//
// Author:	    Steve Lumetta
// Version:	    1.00
// Creation Date:   20 April 2018
// Filename:	    mp12.cpp
// History:
//	SL	1.00	20 April 2018
//		First written.
//

#include <iostream>
#include <list>

#include <math.h>
#include <stdio.h>
#include <string.h>
#include "WALYmain.h"

#include "TurtleScreen.h"

#include "mp5.h"
#include "mp12.h"

using namespace std;
using namespace WALY;

// THESE ARE GLOBAL VARIABLES IN THE INTEREST OF TESTING.  THEY SHOULD
// BE FILE-SCOPE OR LOCAL TO frameUpdate.
FILE*           input = NULL;		// input stream
list<segment_t> lines;			// list of lines drawn
command_t       cmd = {CMD_NONE};	// current command
int32_t	        moveColor = 0xFFFFFF;	// current movement drawing color

// void add_move() {
//
//     if(0 == cmd.framesLeft--){
//       cmd.type = CMD_NONE;
//       return;
//     }
//     segment_t move;
//     move.color = moveColor;
//     move.x1  = cmd.startX;
//     move.x2  = cmd.endX;
//     move.y1  = cmd.startY;
//     move.y2  = cmd.endY;
//     lines.push_back(move);
//
// }

int32_t
is_valid_token(char *ptr){
    if(!strcasecmp(ptr,"color")){
      return 1;
    }
    else if(!strcasecmp(ptr,"turn")){
      return 2;
    }
    else if(!strcasecmp(ptr,"wait")){
      return 3;
    }
    else if(!strcasecmp(ptr,"restart")){
      return 4;
    }
    else if(!strcasecmp(ptr,"move")){
      return 5;
    }
    else{
      return -1;
    }
}

int32_t
set_command (TurtleScreen *ts, char* buf, int32_t type){
    int32_t amt,frames,dist;
    char* ptr;
    if(1 == type)
    {
        if(1 == sscanf(ptr,"%X%1s",&moveColor,ptr)){
          Screen::debug ()<< "argument: " << moveColor << endl;
          set_color(moveColor);
          return 1;
        }
    }
    else if(2 == type){
        if(1 == sscanf(buf,"%d%1s",&amt,ptr)){
            Screen::debug () << "Turn :" << amt << endl;
            cmd.type = CMD_TURN;
            cmd.cmdFrames = cmd.framesLeft = amt;
            cmd.dir = (amt > 0)?(1):(-1);
            cmd.startX = cmd.endX = ts->getX();
            cmd.startY = cmd.endY = ts->getY();
            frameUpdate(ts);
            return 1;
        }
    }
    else if(3 == type){
        if(1 == sscanf(buf,"%d%*[ ]%s",&frames,ptr)){
            Screen::debug () << "frames: " << frames << endl;
            cmd.cmdFrames = cmd.framesLeft = frames;
            cmd.dir = (frames > 0)?(1):(-1);
            cmd.startX = cmd.endX = ts->getX();
            cmd.startY = cmd.endY = ts->getY();
            frameUpdate(ts);
            return 1;
        }
    }
    else if(4 == type){
        if(!sscanf(buf,"%*[ ]%s",ptr)){
          rewind(input);
          return 1;
        }
    }
    else if(5 == type){
        if(1 == sscanf(buf,"%d%*[ ]", &dist) && 1 == sscanf(buf, "")){
            Screen::debug () << "Dist: " << dist << " frames:" << frames << endl;
            cmd.type = CMD_MOVE;
            cmd.cmdFrames = cmd.framesLeft = frames;
            cmd.startX = ts->getX();
            cmd.startY = ts->getY();

            frameUpdate(ts);
            return 1;
        }
      }
    }
    return 0;
}

int32_t
openInputStream (const char* fname)
{
    return (NULL != (input= fopen(fname, "r")));
}

void
closeInputStream (void)
{
    fclose(input);
}

void
showLines (void)
{
    // you can use 'call showLines ()' in GDB to look at the
    // list of segments.  Don't forget to call makeVisibleChange
    // when you change this list, since the background won't be
    // redrawn unless you call that function (so changes will not
    // show up.
    for (list<segment_t>::iterator it = lines.begin ();
	 lines.end () != it; it++) {
     Screen::debug () << it->color << " " << it->x1 << "," << it->y1 << "  " << it->x2 << "," << it->y2 << endl;
    }
}

void
drawEverything (void)
{
    for (list<segment_t>::iterator it = lines.begin ();
   lines.end () != it; it++) {
     set_color(it->color);
     draw_line(it->x1,it->y1,it->x2,it->y2);
    }
}

void
readNewCommand (TurtleScreen* ts)
{
    char buf[201];
    char *ptr;
    char trailing[2];
    int32_t token_type;
    while (!feof(input)) {
        if(fgets(buf,201,input)){
              Screen::debug () << "buffer: " << buf << endl;
              if(1 == sscanf(buf, "%*[ ]%s%*[ ]%1s", ptr, trailing) && -1 != (token_type = is_valid_token(ptr)))){
                  if(!set_command(ts,buf+strlen(ptr),token_type)){
                    //print error message
                  }
              }
              else{
                  //print error message
              }
          }
      }
}

void
frameUpdate (TurtleScreen* ts)
{
    if(CMD_NONE == cmd.type){
        readNewCommand(ts);
    }
    switch (cmd.type) {
      case CMD_MOVE:   /*add_move(ts);*/ break;
      case CMD_TURN:   break;
      case CMD_WAIT:   break;
      case CMD_NONE:   break;
      default: Screen::debug () << "Something's wrong!" << endl;
    }
}
